'''
utils to construct netcdf Look-Up Tables (LUT)
'''
import numpy as np
import pandas as pd


class misc:
    def __init__(self):
        pass

    @staticmethod
    def init_array(number_of_array, dim):
        '''
        Initialize Nd array, Nd dimensions are given by dim
        example:
            arr1, arr2 = init_array(2,(2,3,10))
        gives
            arr1.shape --> (2,3,10)
            arr2.shape --> (2,3,10)

        :param number_of_array: int
        :param dim: list
        :return: `number_of_array` numpy arrays of shape `dim`
        '''
        for i in range(number_of_array):
            yield np.empty(dim)

    @staticmethod
    def arr_format(arr,fmt="{:0.3f}"):
        return [fmt.format(x) for x in arr]

class nc_utils():
    def __init__(self):
        pass

    def walktree(self,top):
        values = top.groups.values()
        yield values
        for value in top.groups.values():
            for children in self.walktree(value):
                yield children

    def print_groups(self,ncobj):
        '''
        print out group elements from a netcdf object
        :param ncobj: netcdf object as loaded with netCDF4.Dataset
        :return:
            '''
        for children in self.walktree(ncobj):
            for child in children:
                print(child)

class iodata():
    def __init__(self, ncfile):
        self.ncfile = ncfile
        self.g_flux = self.ncfile.createGroup('flux')
        self.g_opt_prop = self.ncfile.createGroup('optical_properties')
        self.g_profile = self.ncfile.createGroup('profile')
        self.g_stokes = self.ncfile.createGroup('stokes')

    def particles(self, file, name='aerosol'):
        '''
        Write scattering properties from `file` into the group `name` in netcdf output file (ncfile)
        :param file:  absolute path of file scattering file generated by OSOAA_profile
        :param name: name of the group to be written in the netcdf file
        :return:
        '''

        g_particles = self.g_opt_prop.createGroup(name)

        line = self.get_line_number(file, pattern='end of header', occurrence=1, exact=False)
        p = pd.read_csv(file, sep=':', nrows=line, header=None)
        print(p)

        for i, attr in p.iterrows():
            print(attr)
            _v = g_particles.createVariable(attr[0], np.float32, )
            _v.description = attr[1]
            _v[:] = attr[2]

        # line = get_line_number(aer_file,occurrence=2)
        p = pd.read_csv(file, skiprows=line + 1, sep='\s+')
        p = p.sort_values(by='scatt_ang')

        _dim = g_particles.createDimension('scatt_ang', p.shape[0])
        _v = g_particles.createVariable('scatt_ang', np.float32, ('scatt_ang',))
        _v.units = 'degrees'
        _v.long_name = 'scattering_angle'
        _v[:] = p.scatt_ang.values

        _v = g_particles.createVariable('F11', np.float32, ('scatt_ang'))
        _v.unit = '-'
        _v.long_name = 'F11_scattering_matrix'
        _v.description = 'Term 11 of the scattering matrix (i.e., scattering function)'
        _v[...] = p["P11"].values

        _v = g_particles.createVariable('F12', np.float32, ('scatt_ang'))
        _v.unit = '-'
        _v.long_name = 'F12_normalized_scattering_matrix'
        _v.description = 'Normalized term 12 of the scattering matrix'
        _v[...] = -p["-P12"].values / p["P11"].values

        _v = g_particles.createVariable('F22', np.float32, ('scatt_ang'))
        _v.unit = '-'
        _v.long_name = 'F22_normalized_scattering_matrix'
        _v.description = 'Normalized term 22 of the scattering matrix'
        _v[...] = p["P22"].values / p["P11"].values

        _v = g_particles.createVariable('F33', np.float32, ('scatt_ang'))
        _v.unit = '-'
        _v.long_name = 'F33_normalized_scattering_matrix'
        _v.description = 'Normalized term 33 of the scattering matrix'
        _v[...] = p["P33"].values / p["P11"].values

        return

    def profile_atmo(self, df):

        z = df.iloc[:, 1].values

        _g = self.g_profile.createGroup('atmosphere')

        _dim = _g.createDimension('z', len(z))
        _v = _g.createVariable('z', np.float32, ('z',))
        _v.units = 'meters'
        _v.long_name = 'vertical_coordinates'
        _v.description = 'positive values: altitude in atmosphere, negative values: depth in water'
        _v[:] = z

        _v = _g.createVariable('TOT_ext', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'total_optical_thickness_extinction'
        _v.description = 'Total extinction opt. thickness from top level down to level z'
        _v[:] = df['TAU_EXT'].values

        _v = _g.createVariable('mol_scat_prop', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'molecular_scattering_proportion'
        _v.description = 'scattering proportion due to molecules within layer at level z'
        _v[:] = df['RAY_PC'].values

        _v = _g.createVariable('aero_scat_prop', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'aerosol_scattering_proportion'
        _v.description = 'scattering proportion due to aerosols within layer at level z'
        _v[:] = df['AER_PC'].values

    def profile_water(self, df):

        z = -df.iloc[:, 1].values

        _g = self.g_profile.createGroup('water')

        _dim = _g.createDimension('z', len(z))
        _v = _g.createVariable('z', np.float32, ('z',))
        _v.units = 'meters'
        _v.long_name = 'vertical_coordinates'
        _v.description = 'positive values: altitude in atmosphere, negative values: depth in water'
        _v[:] = z

        _v = _g.createVariable('TOT_ext', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'total_optical_thickness_extinction'
        _v.description = 'Total extinction opt. thickness from top level down to level z'
        _v[:] = df['TAU_EXT'].values

        _v = _g.createVariable('mol_scat_prop', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'molecular_scattering_proportion'
        _v.description = 'scattering proportion due to molecules within layer at level z'
        _v[:] = df['MOL_PC'].values

        _v = _g.createVariable('phyto_scat_prop', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'phytoplankton_scattering_proportion'
        _v.description = 'scattering proportion due to phytoplankton within layer at level z'
        _v[:] = df['PHY_PC'].values

        _v = _g.createVariable('sed_scat_prop', np.float32, ('z'))
        _v.unit = '-'
        _v.long_name = 'sediment_scattering_proportion'
        _v.description = 'scattering proportion due to sediment within layer at level z'
        _v[:] = df['MLP_PC'].values

    def flux(self, df):
        '''

        :param df:
        :return:
        '''

        z = np.array(df.index.get_level_values('Z').unique())

        Ed = df.Ed.to_xarray()
        Eu = df.Eu.to_xarray()
        Eo = df.Eo.to_xarray()
        Eddir = df.Eddir.to_xarray()
        Eudir = df.Eudir.to_xarray()
        Eodir = df.Eodir.to_xarray()

        _g = self.g_flux

        # ---- set dimensions
        _dim = _g.createDimension('z', len(z))
        _v = _g.createVariable('z', np.float32, ('z',))
        _v.units = 'meters'
        _v.long_name = 'vertical_coordinates'
        _v.description = 'positive values: altitude in atmosphere, negative values: depth in water'
        _v[:] = z

        # ---- set variables
        Ed_v = _g.createVariable('Ed', np.float32, ('z', 'sza'))
        Ed_v.unit = '-'
        Ed_v.long_name = 'normalized_downwelling_irradiance'
        Ed_v.description = 'downwelling_irradiance, can be scaled into irradiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Ed_v[...] = Ed.values

        Eu_v = _g.createVariable('Eu', np.float32, ('z', 'sza'))
        Eu_v.unit = '-'
        Eu_v.long_name = 'normalized_upwelling_irradiance'
        Eu_v.description = 'upwelling_irradiance, can be scaled into irradiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Eu_v[...] = Eu.values

        Eo_v = _g.createVariable('Eo', np.float32, ('z', 'sza'))
        Eo_v.unit = '-'
        Eo_v.long_name = 'normalized_spherical_irradiance'
        Eo_v.description = 'downwelling_irradiance, can be scaled into irradiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Eo_v[...] = Eo.values

        Eddir_v = _g.createVariable('Eddir', np.float32, ('z', 'sza'))
        Eddir_v.unit = '-'
        Eddir_v.long_name = 'normalized_direct_downwelling_irradiance'
        Eddir_v.description = 'direct_downwelling_irradiance, can be scaled into irradiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Eddir_v[...] = Eddir.values

        Eudir_v = _g.createVariable('Eudir', np.float32, ('z', 'sza'))
        Eudir_v.unit = '-'
        Eudir_v.long_name = 'normalized_direct_upwelling_irradiance'
        Eudir_v.description = 'direct_upwelling_irradiance, can be scaled into irradiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Eudir_v[...] = Eudir.values

        Eodir_v = _g.createVariable('Eodir', np.float32, ('z', 'sza'))
        Eodir_v.unit = '-'
        Eodir_v.long_name = 'normalized_direct_spherical_irradiance'
        Eodir_v.description = 'direct_spherical_irradiance, can be scaled into irradiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Eodir_v[...] = Eodir.values

    def stokes(self, df, name='up'):

        _g = self.g_stokes.createGroup(name)

        z = np.array(df.index.get_level_values('Z').unique())
        vza = np.array(df.index.get_level_values('VZA').unique())
        azi = np.array(df.index.get_level_values('AZI').unique())

        I = df.I.to_xarray()
        Q = df.Q.to_xarray()
        U = df.U.to_xarray()

        # ---- set dimensions
        _dim = _g.createDimension('z', len(z))
        _v = _g.createVariable('z', np.float32, ('z',))
        _v.units = 'meters'
        _v.long_name = 'vertical_coordinates'
        _v.description = 'positive values: altitude in atmosphere, negative values: depth in water'
        _v[:] = z

        _dim = _g.createDimension('vza', len(vza))
        _v = _g.createVariable('vza', np.float32, ('vza',))
        _v.units = 'degrees'
        _v.long_name = 'viewing_zenith_angle'
        _v[:] = vza

        _dim = _g.createDimension('azi', len(azi))
        _v = _g.createVariable('azi', np.float32, ('azi',))
        _v.units = 'degrees'
        _v.long_name = 'relative_azimuth'
        _v.description = 'equal to 0Â° when satellite and sun in opposition'
        _v[:] = azi

        # ---- set variables
        Istokes = _g.createVariable('I', np.float32, ('z', 'sza', 'vza', 'azi'))
        Istokes.unit = '-'
        Istokes.long_name = 'normalized_radiance'
        Istokes.description = 'I stokes parameter, can be scaled into radiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Istokes[...] = I.values

        Qstokes = _g.createVariable('Q', np.float32, ('z', 'sza', 'vza', 'azi'))
        Qstokes.unit = '-'
        Qstokes.long_name = 'normalized_radiance'
        Qstokes.description = 'Q stokes parameter, can be scaled into radiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Qstokes[...] = Q.values

        Ustokes = _g.createVariable('U', np.float32, ('z', 'sza', 'vza', 'azi'))
        Ustokes.unit = '-'
        Ustokes.long_name = 'normalized_radiance'
        Ustokes.description = 'U stokes parameter, can be scaled into radiance unit by multiplying by the source irradiance (in general F0 / cos(sza))'
        Ustokes[...] = U.values

        return

    @classmethod
    def get_line_number(cls, file, pattern=' RESULTS', occurrence=1, exact=True, verbose=False):
        '''
        Get the line number of a given pattern for the nth occurrence of text file
        :param file: text file
        :param pattern: pattern to match
        :param occurrence: nth occurrence
        :param exact: if True search for exact match, find line containing pattern otherwise
        :param verbose: print line number and line if True (default: False)
        :return: line number
        '''
        with open(file) as search:
            i = 0
            for iline, line in enumerate(search):
                line = line.rstrip()  # remove '\n' at end of line
                if exact:
                    expr = pattern == line
                else:
                    expr = pattern in line
                if expr:
                    i += 1
                    if i == occurrence:
                        if verbose: print(iline, line)
                        return iline

    @classmethod
    def get_dims(cls, df, variables=['Z']):
        dims = []
        for var in variables:
            dims.append(df[var].astype(str).unique().shape[0])
        return dims

    @classmethod
    def get_values(cls, df, variables=['Z'], type=str):
        values = []
        for var in variables:
            values.append(df[var].astype(type).unique())
        if len(variables) == 1:
            return values[0]
        return values


# # TODO add bb coefs
# # keep only Z dimension
# df = df.droplevel(1).drop_duplicates('LEVEL')
#
# c = df.c.to_xarray()
# aw = df.aw.to_xarray()
# achl = df.achl.to_xarray()
# amin = df.amin.to_xarray()
# acdom = df.acdom.to_xarray()
# bw = df.bw.to_xarray()
# bchl = df.bchl.to_xarray()
# bmin = df.bmin.to_xarray()
#
# g_iop = ncfile.createGroup('iop')
# c_v = g_iop.createVariable('c', np.float32, ('z'))
# c_v.unit = 'm-1'
# c_v.long_name = 'attenuation_coefficient'
# c_v.description = 'in-water total attenuation coefficient; values are only expressed for the water layers except for the O- layer'
# c_v[...] = c.values
#
# aw_v = g_iop.createVariable('aw', np.float32, ('z'))
# aw_v.unit = 'm-1'
# aw_v.long_name = 'water_absorption_coefficient'
# aw_v.description = 'in-water water absorption coefficient; values are only expressed for the water layers except for the O- layer'
# aw_v[...] = aw.values
#
# achl_v = g_iop.createVariable('achl', np.float32, ('z'))
# achl_v.unit = 'm-1'
# achl_v.long_name = 'phyto_absorption_coefficient'
# achl_v.description = 'in-water phyto absorption coefficient; values are only expressed for the water layers except for the O- layer'
# achl_v[...] = achl.values
#
# amin_v = g_iop.createVariable('amin', np.float32, ('z'))
# amin_v.unit = 'm-1'
# amin_v.long_name = 'sediment_absorption_coefficient'
# amin_v.description = 'in-water sediment absorption coefficient; values are only expressed for the water layers except for the O- layer'
# amin_v[...] = amin.values
#
# acdom_v = g_iop.createVariable('acdom', np.float32, ('z'))
# acdom_v.unit = 'm-1'
# acdom_v.long_name = 'water_absorption_coefficient'
# acdom_v.description = 'in-water water absorption coefficient; values are only expressed for the water layers except for the O- layer'
# acdom_v[...] = acdom.values
#
# bw_v = g_iop.createVariable('bw', np.float32, ('z'))
# bw_v.unit = 'm-1'
# bw_v.long_name = 'water_scattering_coefficient'
# bw_v.description = 'in-water water scattering coefficient; values are only expressed for the water layers except for the O- layer'
# bw_v[...] = bw.values
#
# bchl_v = g_iop.createVariable('bchl', np.float32, ('z'))
# bchl_v.unit = 'm-1'
# bchl_v.long_name = 'phyto_scattering_coefficient'
# bchl_v.description = 'in-water water absorption coefficient; values are only expressed for the water layers except for the O- layer'
# bchl_v[...] = bchl.values
#
# bmin_v = g_iop.createVariable('bmin', np.float32, ('z'))
# bmin_v.unit = 'm-1'
# bmin_v.long_name = 'sediment_scattering_coefficient'
# bmin_v.description = 'in-water sediment scattering coefficient; values are only expressed for the water layers except for the O- layer'
# bmin_v[...] = bmin.values

